<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Monaco Editor with Tinymist LSP</title>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; }
        .container { display: flex; flex-direction: column; height: 100vh; }
        .header { margin-bottom: 20px; }
        .status { padding: 10px; border-radius: 4px; margin-bottom: 10px; }
        .status.connecting { background: #e3f2fd; border: 1px solid #2196f3; color: #1976d2; }
        .status.connected { background: #e8f5e8; border: 1px solid #4caf50; color: #2e7d32; }
        .status.error { background: #ffebee; border: 1px solid #f44336; color: #c62828; }
        .editor-container { flex: 1; border: 1px solid #ccc; }
        .controls { margin-bottom: 10px; }
        button { padding: 8px 16px; margin-right: 8px; border: none; border-radius: 4px; cursor: pointer; }
        button.primary { background: #2196f3; color: white; }
        button.secondary { background: #f5f5f5; color: #333; border: 1px solid #ddd; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Monaco Editor with Tinymist LSP</h1>
            <div id="status" class="status connecting">Connecting to Tinymist LSP...</div>
            <div class="controls">
                <button id="reconnect" class="secondary">Reconnect</button>
                <button id="format" class="primary">Format Document</button>
            </div>
        </div>
        <div class="editor-container" id="editor"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
    <script>
        require.config({ 
            paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' }
        });

        require(['vs/editor/editor.main'], function() {
            // Register Typst language
            monaco.languages.register({
                id: 'typst',
                extensions: ['.typ'],
                aliases: ['Typst', 'typst'],
                mimetypes: ['text/x-typst']
            });

            // Basic syntax highlighting (fallback)
            monaco.languages.setMonarchTokensProvider('typst', {
                keywords: [
                    'let', 'set', 'show', 'import', 'include', 'if', 'else', 'for', 'in', 
                    'while', 'break', 'continue', 'return', 'function', 'as', 'from'
                ],
                
                tokenizer: {
                    root: [
                        [/#[a-zA-Z_$][\w$]*/, 'keyword.control'],
                        [/\$/, { token: 'string.math', bracket: '@open', next: '@math' }],
                        [/@[a-zA-Z_$][\w$]*/, 'variable.name'],
                        [/[a-z_$][\w$]*/, { cases: { 
                            '@keywords': 'keyword',
                            '@default': 'identifier' 
                        }}],
                        [/\d*\.\d+([eE][\-+]?\d+)?/, 'number.float'],
                        [/\d+/, 'number'],
                        [/"([^"\\]|\\.)*$/, 'string.invalid'],
                        [/"/, { token: 'string.quote', bracket: '@open', next: '@string' }],
                        [/\/\/.*$/, 'comment'],
                        [/\/\*/, 'comment', '@comment'],
                        [/[{}()\[\]]/, '@brackets'],
                    ],
                    math: [
                        [/[^$\\]+/, 'string.math'],
                        [/\\./, 'string.math.escape'],
                        [/\$/, { token: 'string.math', bracket: '@close', next: '@pop' }]
                    ],
                    string: [
                        [/[^\\"]+/, 'string'],
                        [/\\./, 'string.escape'],
                        [/"/, { token: 'string.quote', bracket: '@close', next: '@pop' }]
                    ],
                    comment: [
                        [/[^\/*]+/, 'comment'],
                        [/\/\*/, 'comment', '@push'],
                        [/\*\//, 'comment', '@pop'],
                        [/[\/*]/, 'comment']
                    ]
                }
            });

            class TinymistLSPClient {
                constructor() {
                    this.ws = null;
                    this.messageId = 0;
                    this.pendingRequests = new Map();
                    this.isInitialized = false;
                    this.documentVersion = 0;
                    this.statusElement = document.getElementById('status');
                }

                async connect() {
                    try {
                        this.updateStatus('Connecting to Tinymist LSP...', 'connecting');
                        
                        this.ws = new WebSocket('ws://localhost:8080');
                        
                        this.ws.onopen = () => {
                            this.updateStatus('Connected to Tinymist LSP', 'connected');
                            this.initialize();
                        };

                        this.ws.onmessage = (event) => {
                            try {
                                const message = JSON.parse(event.data);
                                this.handleMessage(message);
                            } catch (error) {
                                console.error('Error parsing message:', error);
                            }
                        };

                        this.ws.onerror = (error) => {
                            console.error('WebSocket error:', error);
                            this.updateStatus('LSP connection error', 'error');
                        };

                        this.ws.onclose = (event) => {
                            this.updateStatus('LSP connection closed', 'error');
                            this.isInitialized = false;
                            
                            // Attempt reconnection after 3 seconds
                            setTimeout(() => {
                                if (!this.ws || this.ws.readyState === WebSocket.CLOSED) {
                                    this.connect();
                                }
                            }, 3000);
                        };
                    } catch (error) {
                        console.error('Connection error:', error);
                        this.updateStatus('Failed to connect to LSP server', 'error');
                    }
                }

                updateStatus(message, type) {
                    this.statusElement.textContent = message;
                    this.statusElement.className = `status ${type}`;
                }

                sendRequest(method, params) {
                    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return Promise.reject('Not connected');
                    
                    const id = this.messageId++;
                    const message = {
                        jsonrpc: '2.0',
                        id: id,
                        method: method,
                        params: params
                    };

                    return new Promise((resolve, reject) => {
                        this.pendingRequests.set(id, { resolve, reject });
                        this.ws.send(JSON.stringify(message));
                        
                        // Timeout after 30 seconds
                        setTimeout(() => {
                            if (this.pendingRequests.has(id)) {
                                this.pendingRequests.delete(id);
                                reject(new Error('Request timeout'));
                            }
                        }, 30000);
                    });
                }

                sendNotification(method, params) {
                    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
                    
                    const message = {
                        jsonrpc: '2.0',
                        method: method,
                        params: params
                    };

                    this.ws.send(JSON.stringify(message));
                }

                async initialize() {
                    try {
                        const response = await this.sendRequest('initialize', {
                            processId: null,
                            rootUri: null,
                            capabilities: {
                                textDocument: {
                                    hover: {
                                        contentFormat: ['markdown', 'plaintext']
                                    },
                                    completion: {
                                        completionItem: {
                                            snippetSupport: true,
                                            documentationFormat: ['markdown', 'plaintext']
                                        }
                                    },
                                    publishDiagnostics: {},
                                    formatting: {},
                                    signatureHelp: {
                                        signatureInformation: {
                                            documentationFormat: ['markdown', 'plaintext']
                                        }
                                    }
                                }
                            }
                        });

                        this.sendNotification('initialized', {});
                        this.isInitialized = true;
                        console.log('LSP initialized:', response);
                    } catch (error) {
                        console.error('Failed to initialize LSP:', error);
                        this.updateStatus('Failed to initialize LSP', 'error');
                    }
                }

                handleMessage(message) {
                    if (message.id !== undefined && this.pendingRequests.has(message.id)) {
                        // Response to a request
                        const { resolve, reject } = this.pendingRequests.get(message.id);
                        this.pendingRequests.delete(message.id);

                        if (message.error) {
                            reject(new Error(message.error.message));
                        } else {
                            resolve(message.result);
                        }
                    } else if (message.method) {
                        // Notification from server
                        this.handleNotification(message.method, message.params);
                    }
                }

                handleNotification(method, params) {
                    switch (method) {
                        case 'textDocument/publishDiagnostics':
                            this.updateDiagnostics(params);
                            break;
                        case 'window/logMessage':
                            console.log(`LSP Log [${params.type}]:`, params.message);
                            break;
                        default:
                            console.log('Unhandled notification:', method, params);
                    }
                }

                updateDiagnostics(params) {
                    const markers = params.diagnostics.map(diag => ({
                        severity: this.severityToMonaco(diag.severity),
                        startLineNumber: diag.range.start.line + 1,
                        startColumn: diag.range.start.character + 1,
                        endLineNumber: diag.range.end.line + 1,
                        endColumn: diag.range.end.character + 1,
                        message: diag.message,
                        source: diag.source
                    }));

                    monaco.editor.setModelMarkers(editor.getModel(), 'tinymist', markers);
                }

                severityToMonaco(severity) {
                    switch (severity) {
                        case 1: return monaco.MarkerSeverity.Error;
                        case 2: return monaco.MarkerSeverity.Warning;
                        case 3: return monaco.MarkerSeverity.Info;
                        case 4: return monaco.MarkerSeverity.Hint;
                        default: return monaco.MarkerSeverity.Info;
                    }
                }

                didOpen(model) {
                    if (!this.isInitialized) return;
                    
                    this.sendNotification('textDocument/didOpen', {
                        textDocument: {
                            uri: 'file:///document.typ',
                            languageId: 'typst',
                            version: this.documentVersion++,
                            text: model.getValue()
                        }
                    });
                }

                didChange(model) {
                    if (!this.isInitialized) return;
                    
                    this.sendNotification('textDocument/didChange', {
                        textDocument: {
                            uri: 'file:///document.typ',
                            version: this.documentVersion++
                        },
                        contentChanges: [{
                            text: model.getValue()
                        }]
                    });
                }

                async getHover(model, position) {
                    if (!this.isInitialized) return null;

                    try {
                        const result = await this.sendRequest('textDocument/hover', {
                            textDocument: { uri: 'file:///document.typ' },
                            position: {
                                line: position.lineNumber - 1,
                                character: position.column - 1
                            }
                        });

                        if (result && result.contents) {
                            return {
                                contents: Array.isArray(result.contents) 
                                    ? result.contents.map(c => ({ value: typeof c === 'string' ? c : c.value }))
                                    : [{ value: typeof result.contents === 'string' ? result.contents : result.contents.value }]
                            };
                        }
                    } catch (error) {
                        console.error('Hover error:', error);
                    }

                    return null;
                }

                async getCompletions(model, position) {
                    if (!this.isInitialized) return { suggestions: [] };

                    try {
                        const result = await this.sendRequest('textDocument/completion', {
                            textDocument: { uri: 'file:///document.typ' },
                            position: {
                                line: position.lineNumber - 1,
                                character: position.column - 1
                            }
                        });

                        if (result && result.items) {
                            const suggestions = result.items.map(item => ({
                                label: item.label,
                                kind: this.completionKindToMonaco(item.kind),
                                insertText: item.insertText || item.label,
                                insertTextRules: item.insertTextFormat === 2 
                                    ? monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet 
                                    : undefined,
                                documentation: item.documentation,
                                detail: item.detail
                            }));

                            return { suggestions };
                        }
                    } catch (error) {
                        console.error('Completion error:', error);
                    }

                    return { suggestions: [] };
                }

                completionKindToMonaco(kind) {
                    const mapping = {
                        1: monaco.languages.CompletionItemKind.Text,
                        2: monaco.languages.CompletionItemKind.Method,
                        3: monaco.languages.CompletionItemKind.Function,
                        4: monaco.languages.CompletionItemKind.Constructor,
                        5: monaco.languages.CompletionItemKind.Field,
                        6: monaco.languages.CompletionItemKind.Variable,
                        7: monaco.languages.CompletionItemKind.Class,
                        8: monaco.languages.CompletionItemKind.Interface,
                        9: monaco.languages.CompletionItemKind.Module,
                        10: monaco.languages.CompletionItemKind.Property,
                        11: monaco.languages.CompletionItemKind.Unit,
                        12: monaco.languages.CompletionItemKind.Value,
                        13: monaco.languages.CompletionItemKind.Enum,
                        14: monaco.languages.CompletionItemKind.Keyword,
                        15: monaco.languages.CompletionItemKind.Snippet,
                        16: monaco.languages.CompletionItemKind.Color,
                        17: monaco.languages.CompletionItemKind.File,
                        18: monaco.languages.CompletionItemKind.Reference
                    };
                    return mapping[kind] || monaco.languages.CompletionItemKind.Text;
                }
            }

            // Initialize LSP client
            const lspClient = new TinymistLSPClient();
            lspClient.connect();

            // Create editor
            const editor = monaco.editor.create(document.getElementById('editor'), {
                value: `= Tinymist LSP Demo

This document demonstrates real LSP integration with Tinymist.

#let author = "John Doe"
#let title = "My Typst Document"

// Try hovering over functions for documentation
// Try Ctrl+Space for completions

#heading(level: 1)[Introduction]

Here's some *bold* and _italic_ text.

Math equation: $ sum_(i=1)^n i = (n(n+1))/2 $

#table(
  columns: 3,
  [Name], [Age], [City],
  [Alice], [25], [New York],
  [Bob], [30], [London]
)

// The LSP provides:
// - Real-time error checking
// - Hover information
// - Auto-completion
// - Go-to-definition (when available)
`,
                language: 'typst',
                theme: 'vs-dark',
                automaticLayout: true,
                minimap: { enabled: true },
                fontSize: 14
            });

            const model = editor.getModel();

            // Register LSP providers
            monaco.languages.registerHoverProvider('typst', {
                provideHover: (model, position) => {
                    return lspClient.getHover(model, position);
                }
            });

            monaco.languages.registerCompletionItemProvider('typst', {
                provideCompletionItems: (model, position) => {
                    return lspClient.getCompletions(model, position);
                }
            });

            // Handle document events
            let changeTimeout;
            model.onDidChangeContent(() => {
                clearTimeout(changeTimeout);
                changeTimeout = setTimeout(() => {
                    lspClient.didChange(model);
                }, 300); // Debounce changes
            });

            // Notify LSP when document opens (after initialization)
            const waitForInitialization = () => {
                if (lspClient.isInitialized) {
                    lspClient.didOpen(model);
                } else {
                    setTimeout(waitForInitialization, 100);
                }
            };
            waitForInitialization();

            // Button handlers
            document.getElementById('reconnect').onclick = () => {
                lspClient.connect();
            };

            document.getElementById('format').onclick = async () => {
                // Format document functionality would go here
                console.log('Format document (not implemented yet)');
            };
        });
    </script>
</body>
</html>
